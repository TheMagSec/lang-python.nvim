*gpack.txt*
                        NVIM EXTENSION PLUGIN

             Thanks to the neovim developers for `vim.pack`,
               which was the inspiration for this plugin.

                ( see installation instructions below )

==============================================================================
GPack Plugin Manager                                       *vim.gpack* *gpack*

This package manager was inspired and replicates the builtin `vim.pack` 
(neovim += 0.12) package manager, with a few key differenes. The first one 
being, that instead of using standard git clones for the packages (repos), 
it uses a git-bare repository, to reduce used disk space. The second key 
difference is the default managed directory, into which the packages are 
added, which is inside the configuration directory. 
Additionally, this implementation provides some cleanup mechanism, to further
reduce the used diskspace of packages, which usually removes standard repo
management, maintanance and workflow files.

Manages plugins in a dedicated *gpack.config.pack_directory* (see |packages|):
defaults to `vim.fn.stdpath('config') .. '/pack'`, which n most cases refers 
to `$XDG_CONFIG_HOME/nvim/pack`. This path needs to be part of 'packpath'. 
All managed packages are can be found in the sub-directory `gpack`.
It is assumed that all plugins in the directory are managed 
exclusively by `gpack`.

It uses Git to manage plugins and requires present `git` executable of at least
version 2.36. Target plugins should be Git repositories with versions as named
tags following semver convention `v<major>.<minor>.<patch>` or `<major>.<minor>.<patch>`.


Commands ~

  :GPack add     {spec}  Install a package (example)
  :GPack remove  {name}  Remove a package (example)
  :GPack list            Show installed packages (example)


Usage ~

Add the following line at the top of your 'init.lua': >lua

    vim.gpack = require('gpack')
<
This adds the `gpack` module as a shortcut onto `vim.gpack` to
replicate the behavior of `vim.pack` (nvim >= 0.12). Additionally,
this eliminates the need to `require('gpack')` in other configuration modules.
Lua command examples can be found below (see `).


Customization ~

To change the default behavior of `gpack`, the following options are defaults and
can be modified to your needs: >lua

   vim.gpack = require('gpack').setup({
     group = 'gpack',
     pack_directory = vim.fn.stdpath('config') .. '/pack',
     cleanup_regex_list = {
        '\.*', 
     }
   }) 
<

Example workflows ~

Basic install and management:
• Add |vim.gpack.add()| call(s) to 'init.lua': >lua

    vim.gpack.add({
      -- Install 'plugin1' and use default branch (usually `main` or `master`)
      'https://github.com/user/plugin1',

      -- Same as above, but using a table (allows setting other options)
      { src = 'https://github.com/user/plugin1' },

      -- Specify plugin's name (here the plugin will be called 'plugin2'
      -- instead of 'generic-name')
      { src = 'https://github.com/user/generic-name', name = 'plugin2' },

      -- Specify version to follow during install and update
      {
        src = 'https://github.com/user/plugin3',
        -- Version constraint, see |vim.version.range()|
        version = vim.version.range('1.0'),
      },
      {
        src = 'https://github.com/user/plugin4',
        -- Git branch, tag, or commit hash
        version = 'main',
      },
    })

    -- Plugin's code can be used directly after `add()`
    plugin1 = require('plugin1')
<
• Restart Nvim (for example, with |:restart|). Plugins that were not yet
  installed will be available on disk in target state after `add()` call.
• To update all plugins with new changes:
  • Execute |vim.gpack.update()|. This will download updates from source and
    show confirmation buffer in a separate tabpage.
  • Review changes. To confirm all updates execute |:write|. To discard
    updates execute |:quit|.

Switch plugin's version:
• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin
  named 'plugin1' has changed to `vim.version.range('*')`.
• |:restart|. The plugin's actual state on disk is not yet changed.
• Execute `vim.gpack.update({ 'plugin1' })`.
• Review changes and either confirm or discard them. If discarded, revert any
  changes in 'init.lua' as well or you will be prompted again next time you
  run |vim.gpack.update()|.

Freeze plugin from being updated:
• Update 'init.lua' for plugin to have `version` set to current commit hash.
  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking
  the word describing current state (looks like `abc12345`).
• |:restart|.

Unfreeze plugin to start receiving updates:
• Update 'init.lua' for plugin to have `version` set to whichever version you
  want it to be updated.
• |:restart|.

Remove plugins from disk:
• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their
  specs are not included in |vim.pack.add()| call in 'init.lua' or they will
  be reinstalled.

Available events to hook into ~
• *PackChangedPre* - before trying to change plugin's state.
• *PackChanged* - after plugin's state has changed.

Each event populates the following |event-data| fields:
• `kind` - one of 'install' (install on disk), 'update' (update existing
  plugin), 'delete' (delete from disk).
• `spec` - plugin's specification with defaults made explicit.
• `path` - full path to plugin's directory.

*gpack.Spec*                                                  *vim.gpack.Spec*

    Fields: ~
      • {src}       (`string`) URI from which to install and pull updates. Any
                    format supported by `git clone` is allowed.
      • {name}?     (`string`) Name of plugin. Will be used as directory name.
                    Default: `src` repository name.
      • {version}?  (`string|vim.VersionRange`) Version to use for install and
                    updates. Can be:
                    • `nil` (no value, default) to use repository's default
                      branch (usually `main` or `master`).
                    • String to use specific branch, tag, or commit hash.
                    • Output of |vim.version.range()| to install the
                      greatest/last semver tag inside the version constraint.
      • {data}?     (`any`) Arbitrary data associated with a plugin.

Example workflows ~

Basic install and management:
• Add |vim.gpack.add()| call(s) to 'init.lua': >lua


add({specs}, {opts})                                         *vim.gpack.add()*

vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl: